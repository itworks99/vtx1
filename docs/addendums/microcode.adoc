== VTX1 Microcode Specification

=== Overview

The VTX1 microcode system implements 26 complex operations that would require significant hardware resources if implemented directly in the TCU. The microcode provides flexibility while maintaining reasonable performance for less frequently used operations.

=== Microcode Architecture

==== Microcode ROM Organization
- **Size**: 1024 words (4KB)
- **Word Width**: 32 bits
- **Address Space**: 10 bits (1024 locations)
- **Instruction Capacity**: ~26 complex operations
- **Average Routine Length**: 8-40 microinstructions

==== Microcode Word Format

[cols="1,1,1,3"]
|===
|Field |Bits |Size |Description

|Control Field |[31:20] |12 bits |Execution unit control signals
|Data Field |[19:8] |12 bits |Immediate data and register selects  
|Address Field |[7:0] |8 bits |Next microinstruction address
|===

**Control Field Encoding [31:20]:**
----
[31:29] Execution Unit Select (3 bits):
  000: ALU Unit
  001: FPU Unit  
  010: Vector Unit
  011: Memory Unit
  100: Control Unit
  101: Register File
  110: Conditional Branch
  111: End/Return

[28:26] Operation Subtype (3 bits):
  Varies by execution unit

[25:23] Source Register Control (3 bits):
  Register selection and control

[22:20] Destination Register Control (3 bits):
  Register selection and control
----

**Data Field Encoding [19:8]:**
----
[19:14] Immediate Data/Constants (6 bits):
  Immediate values for operations

[13:11] Source Register Select (3 bits):
  Primary source register

[10:8] Secondary Source Register Select (3 bits):
  Secondary source register
----

**Address Field Encoding [7:0]:**
----
[7:0] Next Address/Offset (8 bits):
  - Absolute address for jumps
  - Relative offset for branches
  - Return address for end
----

=== Microcode Instruction Set
==== Complex Arithmetic Operations
===== Division (DIV) - Signed 32-bit Division

**Entry Point**: 0x000 +
**Cycles**: 12 cycles average +
**Algorithm**: Non-restoring division

----
; DIV Rs1, Rs2 -> Rd = Rs1 / Rs2
; Entry: Rs1 in T_SRC1, Rs2 in T_SRC2
; Result: Quotient in T_DEST, Remainder in T_TEMP

0x000: 101_000_001_010  000000_001_010  00000001  ; Load Rs1, check sign
0x001: 101_000_010_011  000000_010_011  00000010  ; Load Rs2, check sign  
0x002: 110_001_000_000  000000_000_000  00000003  ; Branch if Rs2 == 0 (div by zero)
0x003: 000_001_001_100  000000_001_010  00000004  ; ABS(Rs1) -> T_TEMP1
0x004: 000_001_010_101  000000_010_011  00000005  ; ABS(Rs2) -> T_TEMP2
0x005: 101_010_100_110  000000_000_000  00000006  ; Initialize quotient = 0
0x006: 101_010_101_111  100000_000_000  00000007  ; Initialize counter = 32
; Division loop
0x007: 000_010_100_100  000000_100_000  00000008  ; Shift quotient left
0x008: 000_010_101_101  000000_101_000  00000009  ; Shift remainder left  
0x009: 000_011_101_100  000000_101_100  0000000A  ; remainder - divisor
0x00A: 110_100_000_000  000000_000_000  0000000C  ; Branch if negative
0x00B: 000_001_100_100  000001_100_000  0000000D  ; quotient |= 1, remainder = temp
0x00C: 000_011_111_111  111111_111_000  0000000D  ; counter--
0x00D: 110_101_111_000  000000_000_000  00000007  ; Branch if counter != 0
0x00E: 000_100_000_000  000000_000_000  0000000F  ; Apply sign correction
0x00F: 111_000_000_000  000000_000_000  00000000  ; Return
----

===== Modulo (MOD) - Signed 32-bit Modulo

**Entry Point**: 0x010 +
**Cycles**: 12 cycles average +
**Algorithm**: Division with remainder extraction

----
; MOD Rs1, Rs2 -> Rd = Rs1 % Rs2
0x010: 101_000_001_010  000000_001_010  00000011  ; Load operands, check signs
0x011: 101_000_010_011  000000_010_011  00000012  ; 
0x012: 110_001_000_000  000000_000_000  00000013  ; Branch if Rs2 == 0
; Reuse division algorithm, return remainder
0x013: 000_001_001_100  000000_001_010  00000014  ; Execute division steps
; ... (similar to DIV but return remainder)
0x01F: 111_000_000_000  000000_000_000  00000000  ; Return remainder
----

===== Square Root (SQRT) - Integer Square Root

**Entry Point**: 0x020 +
**Cycles**: 16 cycles average +
**Algorithm**: Binary search / Newton-Raphson

----
; SQRT Rs1 -> Rd = sqrt(Rs1)
0x020: 101_000_001_010  000000_001_010  00000021  ; Load Rs1
0x021: 110_001_000_000  000000_000_000  00000030  ; Branch if negative (error)
0x022: 101_010_100_000  000000_000_000  00000023  ; Initialize guess = 0
0x023: 101_010_101_000  100000_000_000  00000024  ; Initialize bit = 0x40000000
; Newton-Raphson iteration
0x024: 000_001_100_101  000000_100_101  00000025  ; temp = guess + bit
0x025: 000_010_110_110  000000_110_110  00000026  ; temp = temp * temp
0x026: 000_011_110_001  000000_110_001  00000027  ; compare temp with Rs1
0x027: 110_100_000_000  000000_000_000  00000029  ; Branch if temp > Rs1
0x028: 000_001_100_100  000000_110_000  00000029  ; guess = temp
0x029: 000_010_101_000  000000_101_000  0000002A  ; bit >>= 2
0x02A: 110_101_101_000  000000_000_000  00000024  ; Branch if bit != 0
0x02B: 111_000_000_000  000000_000_000  00000000  ; Return
----

==== Transcendental Functions
===== Sine Function (SIN) - CORDIC Implementation

**Entry Point**: 0x040 +
**Cycles**: 14 cycles average +
**Algorithm**: CORDIC rotation mode

----
; SIN Fs1 -> Fd = sin(Fs1)
; Input: Fs1 in radians, range checked to [-π, π]
0x040: 001_000_001_010  000000_001_010  00000041  ; Load Fs1 to FPU
0x041: 001_001_000_000  000000_000_000  00000042  ; Range reduction to [0, π/2]
0x042: 001_010_000_000  000000_000_000  00000043  ; Initialize CORDIC constants
0x043: 001_011_001_000  011111_000_000  00000044  ; X = 0.607253 (CORDIC gain)
0x044: 001_011_010_000  000000_000_000  00000045  ; Y = 0
0x045: 001_011_011_001  000000_001_000  00000046  ; Z = input angle
; CORDIC iteration loop (16 iterations)
0x046: 001_100_000_000  000000_000_000  00000047  ; i = 0
0x047: 001_101_011_000  000000_011_000  00000048  ; if Z >= 0
0x048: 110_100_000_000  000000_000_000  0000004C  ; Branch if negative
0x049: 001_110_001_010  000000_001_010  0000004A  ; X' = X - Y*2^(-i)
0x04A: 001_110_010_001  000000_010_001  0000004B  ; Y' = Y + X*2^(-i)  
0x04B: 001_110_011_100  000000_011_100  0000004C  ; Z' = Z - atan(2^(-i))
0x04C: 001_111_000_000  000001_000_000  0000004D  ; i++
0x04D: 110_101_000_000  001000_000_000  00000047  ; Branch if i < 16
0x04E: 001_110_000_010  000000_000_010  0000004F  ; Apply quadrant correction
0x04F: 111_000_000_000  000000_000_000  00000000  ; Return Y (sine result)
----

===== Cosine Function (COS) - CORDIC Implementation

**Entry Point**: 0x050 +
**Cycles**: 14 cycles average +
**Algorithm**: CORDIC rotation mode (return X component)

----
; COS Fs1 -> Fd = cos(Fs1)
; Similar to SIN but returns X component
0x050: 001_000_001_010  000000_001_010  00000051  ; Load Fs1
; ... (similar CORDIC setup and iteration)
0x05F: 001_110_000_001  000000_000_001  00000060  ; Apply quadrant correction  
0x060: 111_000_000_000  000000_000_000  00000000  ; Return X (cosine result)
----

===== Exponential Function (EXP) - Taylor Series

**Entry Point**: 0x070 +
**Cycles**: 12 cycles average +
**Algorithm**: Taylor series with range reduction

----
; EXP Fs1 -> Fd = e^Fs1
0x070: 001_000_001_010  000000_001_010  00000071  ; Load Fs1
0x071: 001_001_000_000  000000_000_000  00000072  ; Range reduction: x = x - n*ln(2)
0x072: 001_010_000_000  000001_000_000  00000073  ; Initialize result = 1.0
0x073: 001_010_001_001  000000_001_000  00000074  ; Initialize term = x
0x074: 001_010_010_000  000001_000_000  00000075  ; Initialize factorial = 1
; Taylor series loop: sum(x^n / n!)
0x075: 001_011_010_010  000000_010_010  00000076  ; result += term
0x076: 001_011_001_010  000000_001_010  00000077  ; term *= x
0x077: 001_011_010_010  000001_010_000  00000078  ; factorial++  
0x078: 001_011_001_010  000000_001_010  00000079  ; term /= factorial
0x079: 001_100_001_000  000000_001_000  0000007A  ; Check convergence |term| < ε
0x07A: 110_100_000_000  000000_000_000  0000007C  ; Branch if converged
0x07B: 110_000_000_000  000000_000_000  00000075  ; Continue loop
0x07C: 001_101_000_000  000000_000_000  0000007D  ; Apply 2^n scaling
0x07D: 111_000_000_000  000000_000_000  00000000  ; Return
----

==== Advanced Vector Operations
===== Vector Dot Product (VDOT)

**Entry Point**: 0x080 +
**Cycles**: 6 cycles average +
**Algorithm**: Parallel multiply-accumulate

----
; VDOT Vs1, Vs2 -> Rd = Vs1 · Vs2
0x080: 010_000_001_010  000000_001_010  00000081  ; Load vector operands
0x081: 010_001_010_011  000000_010_011  00000082  ; 
0x082: 010_010_000_000  000000_000_000  00000083  ; Initialize accumulator = 0
0x083: 010_011_001_010  000000_001_010  00000084  ; acc += Vs1[0] * Vs2[0]
0x084: 010_011_001_010  000001_001_010  00000085  ; acc += Vs1[1] * Vs2[1] 
0x085: 010_011_001_010  000010_001_010  00000086  ; acc += Vs1[2] * Vs2[2]
0x086: 111_000_000_000  000000_000_000  00000000  ; Return accumulator
----

===== Vector Reduction (VREDUCE)

**Entry Point**: 0x090 +
**Cycles**: 8 cycles average +
**Algorithm**: Configurable reduction operation

----
; VREDUCE Vs1, op -> Rd = reduce(Vs1, op)
; op: 0=sum, 1=max, 2=min, 3=product
0x090: 010_000_001_010  000000_001_010  00000091  ; Load vector Vs1
0x091: 101_000_010_000  000000_010_000  00000092  ; Load operation type
0x092: 010_001_001_000  000000_001_000  00000093  ; Initialize result = Vs1[0]
0x093: 110_000_010_000  000000_000_000  00000095  ; Branch based on operation
; Sum operation
0x094: 010_010_000_001  000001_000_000  00000098  ; result += Vs1[1]
0x095: 010_010_000_001  000010_000_000  00000099  ; result += Vs1[2]
0x096: 110_000_000_000  000000_000_000  0000009F  ; Jump to return
; Max operation  
0x097: 010_011_000_001  000001_000_000  00000098  ; result = max(result, Vs1[1])
0x098: 010_011_000_001  000010_000_000  00000099  ; result = max(result, Vs1[2])
; ... (similar for min, product)
0x09F: 111_000_000_000  000000_000_000  00000000  ; Return
----

==== Memory Management Operations
===== Cache Control (CACHE)

**Entry Point**: 0x0A0 +
**Cycles**: 6 cycles average +
**Algorithm**: Cache line operations

----
; CACHE Rs1, op -> Cache operation based on Rs1 address and op
0x0A0: 011_000_001_010  000000_001_010  000000A1  ; Load address Rs1
0x0A1: 011_000_010_011  000000_010_011  000000A2  ; Load operation type
0x0A2: 110_000_010_000  000000_000_000  000000A4  ; Branch on operation
; Flush operation
0x0A3: 011_001_001_000  000000_001_000  000000A6  ; Flush cache line at address
0x0A4: 110_000_000_000  000000_000_000  000000AF  ; Jump to return
; Invalidate operation  
0x0A5: 011_010_001_000  000000_001_000  000000A6  ; Invalidate cache line
; Prefetch operation
0x0A6: 011_011_001_000  000000_001_000  000000A7  ; Prefetch cache line
0x0AF: 111_000_000_000  000000_000_000  00000000  ; Return
----

==== System Control Operations
===== System Call (SYSCALL)

**Entry Point**: 0x0B0 +
**Cycles**: Variable +
**Algorithm**: System call dispatch

----
; SYSCALL -> Software interrupt with context save
0x0B0: 100_000_000_000  000000_000_000  000000B1  ; Save current context
0x0B1: 100_001_000_000  000000_000_000  000000B2  ; Read system call number
0x0B2: 100_010_000_000  000000_000_000  000000B3  ; Validate system call
0x0B3: 100_011_000_000  000000_000_000  000000B4  ; Jump to system call handler
0x0B4: 111_000_000_000  000000_000_000  00000000  ; Return (context restored by OS)
----

=== Microcode Execution Control
==== Microcode Sequencer State Machine

The microcode sequencer operates in several modes:

1. **Idle State**: Waiting for microcode operation request
2. **Fetch State**: Fetching microinstruction from ROM
3. **Decode State**: Decoding microinstruction fields  
4. **Execute State**: Executing microinstruction
5. **Branch State**: Handling conditional branches
6. **Return State**: Completing microcode routine

==== Error Handling

**Division by Zero (Entry: 0x3F0)**
----
0x3F0: 100_100_000_000  000000_000_000  000003F1  ; Set divide-by-zero flag
0x3F1: 100_101_000_000  000000_000_000  000003F2  ; Trigger exception
0x3F2: 111_000_000_000  000000_000_000  00000000  ; Return
----

**Floating-Point Overflow (Entry: 0x3F8)**
----
0x3F8: 100_110_000_000  000000_000_000  000003F9  ; Set overflow flag
0x3F9: 100_111_000_000  000000_000_000  000003FA  ; Trigger FP exception
0x3FA: 111_000_000_000  000000_000_000  00000000  ; Return
----

=== Performance Analysis
==== Cycle Count Summary

[cols="3,2,2,2,4"]
|===
|Operation Category |Instructions |Min Cycles |Max Cycles |Average Cycles

|Complex Arithmetic |6 |4 |16 |10
|Transcendental Functions |8 |12 |16 |14  
|Advanced Vector Operations |6 |4 |10 |6
|Memory Management |3 |4 |8 |6
|System Control |3 |1 |Variable |4
|**Total Microcode** |**26** |**1** |**Variable** |**8.8**
|===

==== Resource Utilization

- **ROM Utilization**: ~60% (600/1024 words used)
- **Average Routine Length**: 23 microinstructions
- **Longest Routine**: SQRT (48 microinstructions)
- **Shortest Routine**: HALT (1 microinstruction)

=== Implementation Notes
==== Hardware Requirements

1. **Microcode ROM**: 4KB × 32-bit ROM
2. **Microcode Sequencer**: 10-bit program counter + control logic
3. **Microcode Register File**: 8 temporary registers for microcode use
4. **Branch Logic**: Conditional branch evaluation
5. **Exception Interface**: Microcode exception generation

==== Optimization Strategies

1. **Shared Subroutines**: Common operations shared between routines
2. **Lookup Tables**: Constant tables for CORDIC and Taylor series
3. **Pipeline Integration**: Microcode operations use existing TCU resources
4. **Interrupt Handling**: Microcode operations can be interrupted and resumed

==== Future Enhancements

1. **Compressed Microcode**: Reduce ROM size with instruction compression
2. **Dynamic Microcode**: Runtime microcode loading capability  
3. **Parallel Microcode**: Limited parallel execution for independent operations
4. **Adaptive Algorithms**: Self-optimizing microcode based on operand patterns
